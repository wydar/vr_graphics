<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webvr - cubes</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
		<link type="text/css" rel="stylesheet" href="main.css">
		<!-- WebXR Device API (For Chrome M76+), expires 10/16/2019 -->
		<meta http-equiv="origin-trial" content="AtWCPo0cZgy0zJDSYftemy7eZvmcwR5qy/4osFkMkLZ0ar6OYyKfbu93pjpxiOVzcWNIVxgoWoK8YtxCXeFSqgIAAABTeyJvcmlnaW4iOiJodHRwczovL3RocmVlanMub3JnOjQ0MyIsImZlYXR1cmUiOiJXZWJYUkRldmljZU03NiIsImV4cGlyeSI6MTU3MTE4Mzk5OX0=">
	</head>
	<body>

		

		<script src="lib/HelioWebXRPolyfill.js"></script>
		<script src="lib/three.js"></script>
		<script src="lib/BoxLineGeometry.js"></script>
		<script src="lib/WebVRvar.js"></script>

		<script>

			
			var clock = new THREE.Clock();

			var container;
			var camera, scene, raycaster, renderer;

			var room;
			var isMouseDown = false;

			var INTERSECTED;
			var crosshair;

			var cube, cube2, grupo, user, grupoGordo;

			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x505050 );

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 10 );
				scene.add( camera );

				crosshair = new THREE.Mesh(
					new THREE.RingBufferGeometry( 0.02, 0.04, 32 ),
					new THREE.MeshBasicMaterial( {
						color: 0xffffff,
						opacity: 0.5,
						transparent: true
					} )
				);
				crosshair.position.z = - 2;
				camera.add( crosshair );

				room = new THREE.LineSegments(
					new THREE.BoxLineGeometry( 18, 18, 18, 10, 10, 10 ),
					new THREE.LineBasicMaterial( { color: 0x808080 } )
				);
				room.position.y = 3;
				scene.add( room );

				scene.add( new THREE.HemisphereLight( 0x606060, 0x404040 ) );

				var light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( 1, 1, 1 ).normalize();
				scene.add( light );

				//Inluyo las piramides
				var geometry = new THREE.CylinderGeometry(0, 2, 4, 4, 1, false);
				var material = new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } );
				cube = new THREE.Mesh( geometry, material ); 
				cube.position.set(-2,2,-8);
				cube.name='cubo';
				
				var geometry2 = geometry.clone();
				var material2 = new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } );
				cube2 = new THREE.Mesh( geometry2, material2);
				cube2.position.set(2,2,8);
				cube2.name='cubo2';
			
			
				grupo = new THREE.Object3D();
				grupo.add(cube);
				grupo.add(cube2);
				scene.add(grupo);

				//Incluyo las flechas para mover las camaras
				var rowGroup = new THREE.Object3D();

				var geometryRows = new THREE.CylinderGeometry(0, 2, 2, 4, 1, false);
				var materialRows = new THREE.MeshBasicMaterial({color: '#2ace4d'});
				var row = new THREE.Mesh(geometryRows, materialRows);
				row.position.set(0,5,-11);
				row.name = 'tr';
				rowGroup.add(row);

				var row2 = new THREE.Mesh(geometryRows, materialRows); 
				row2.position.set(-4,1,-11);
				row2.rotation.z = Math.PI/2;
				row2.name= 'lr';
				rowGroup.add(row2);

				var row3 = new THREE.Mesh(geometryRows, materialRows); 
				row3.position.set(4,1,-11);
				row3.rotation.z = -Math.PI/2;
				row3.name= 'rr';
				rowGroup.add(row3);

				var row4 = new THREE.Mesh(geometryRows, materialRows);
				row4.position.set(0,-3,-11);
				row4.rotation.z = Math.PI;
				row4.name = 'br';
				rowGroup.add(row4);

				scene.add(rowGroup);

				// Usuario añadido para poder mover la cámara
				user = new THREE.Group();
				user.name = "User";
				user.position.set(0,0,0);
				user.add( camera );
				scene.add(user);

				grupoGordo = new THREE.Object3D();
				//grupoGordo.add(grupo);
				//grupoGordo.add(rowGroup);
				//console.log(grupoGordo.children[0]);


				raycaster = new THREE.Raycaster();

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.vr.enabled = true;
				container.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize, false );

				window.addEventListener( 'vrdisplaypointerrestricted', onPointerRestricted, false );
				window.addEventListener( 'vrdisplaypointerunrestricted', onPointerUnrestricted, false );

				document.body.appendChild( WEBVR.createButton( renderer ) );

			}

			function onPointerRestricted() {

				var pointerLockElement = renderer.domElement;
				if ( pointerLockElement && typeof ( pointerLockElement.requestPointerLock ) === 'function' ) {

					pointerLockElement.requestPointerLock();

				}

			}

			function onPointerUnrestricted() {

				var currentPointerLockElement = document.pointerLockElement;
				var expectedPointerLockElement = renderer.domElement;
				if ( currentPointerLockElement && currentPointerLockElement === expectedPointerLockElement && typeof ( document.exitPointerLock ) === 'function' ) {

					document.exitPointerLock();

				}

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				renderer.setAnimationLoop( render );

			}

			renderer.setAnimationLoop( render );

			function render() {

				// find intersections

				raycaster.setFromCamera( { x: 0, y: 0 }, camera );

				var intersects = raycaster.intersectObjects( grupo.children );

				if ( intersects.length > 0 ) {

					if ( INTERSECTED != intersects[ 0 ].object ) {
						INTERSECTED = intersects[ 0 ].object;
					}

				} else {
					INTERSECTED = undefined;

				}

				if(typeof INTERSECTED !== 'undefined'){
					if( INTERSECTED.name == 'cubo'){
						cube.rotation.y -= 0.1; 
					}

					if(INTERSECTED.name == 'cubo2'){
						cube2.rotation.y -= 0.1; 
					}

					if(INTERSECTED.name == 'tr'){
						user.rotation.y += 0.1;
						console.log('gg');
					}
				}

				//user.rotation.y +=0.1;
				grupo.rotation.y += 0.01;
				renderer.render( scene, camera ); 

			}

		</script>
	</body>
</html>
